<!doctype html>
<html lang="en">
<head>
  <meta name="referrer" content="origin">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <title>Hacker Book — Community, All the HN Belong to You! 2006 - 2025 FOREVER</title>
  <link rel="icon" type="image/png" href="cd.png?v=20251230">
  <link rel="stylesheet" href="vendor/uplot/uPlot.min.css">
  <style>
    html { -webkit-text-size-adjust: 100%; text-size-adjust: 100%; overflow-x: hidden; }
    body { font-family: Verdana, Geneva, sans-serif; font-size: 10pt; color:#000; margin:0; -webkit-text-size-adjust: 100%; text-size-adjust: 100%; overflow-x: hidden; }
    a:link { color:#0000cc; text-decoration:none; }
    a:visited { color:#828282; text-decoration:none; }
    .morelink:visited { color:#0000cc; }
    a:hover { text-decoration:underline; }
    #hnmain { background:#f6f6ef; max-width: 100vw; }
    .topbar { background:#9a9a9a; } /* archive gray */
    .pagetop { font-size:10pt; color:#000; }
    .nav-cell {
      vertical-align: middle;
      height: 100%;
      min-height: 28px;
    }
    .nav-wrap {
      display: flex;
      align-items: center;
      height: 100%;
    }
    .pagetop a { color:#000; }
    .pagetop a:hover { text-decoration:none; }
    .hnname a { font-weight:bold; }
    .itemlist { width:100%; }
    .title { font-size:10pt; }
    .subtext { font-size:7pt; color:#828282; }
    .subtext a { color:#828282; }
    .rank { color:#828282; }
    .spacer { height:5px; }
    .morelink { color:#0000cc; }
    .votelinks { width: 14px; }
    .archive-dot {
      width: 6px; height: 6px;
      background: #9a9a9a;
      border-radius: 50%;
      display: inline-block;
      margin-top: 4px;
      opacity: 0.5;
    }
    .loading { color:#828282; font-style:italic; }
    .hr { height:1px; background:#9a9a9a; margin:8px 0; }
    .commtext {
      font-size: 9pt;
      line-height: 1.4;
      max-width: 72ch;
      word-wrap: break-word;
      overflow-wrap: break-word;
      margin-right: 20px;
      white-space: pre-wrap;
    }
    .commtext p { margin: 0 0 0.8em 0; }
    .commtext p:last-child { margin-bottom: 0; }
    .commtext a { color: #666; }
    .commtext a:visited { color: #888; }
    .commtext pre, .commtext code {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 8.5pt;
      white-space: pre-wrap;
      word-wrap: break-word;
      background: #f0f0f0;
      padding: 1px 3px;
    }
    .commtext pre {
      display: block;
      padding: 6px 8px;
      margin: 0.5em 0;
      overflow-x: auto;
      white-space: pre;
      max-width: none;
    }
    .comhead { font-size: 8pt; color: #828282; }
    .comhead a { color: #828282; }
    .comhead .hnuser { color: #828282; }
    .error { color:#b00020; white-space:pre-wrap; font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 9pt; }
    .archive-badge {
      background: #9a9a9a;
      color: #fff;
      font-size: 7pt;
      padding: 1px 4px;
      border-radius: 2px;
      font-weight: normal;
    }
    .archive-badge-link { text-decoration: none; display: flex; }
    .archive-badge-link:hover { text-decoration: none; }
    .status-cell {
      width: 320px;
      white-space: nowrap;
    }
    .header-right {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
    }
    .date-row {
      display: inline-flex;
      align-items: center;
      justify-content: flex-end;
      gap: 3px;
      width: 100%;
    }
    #status-right, #status-mid {
      color: #111;
      font-size: 8pt;
      display: inline-block;
      width: 180px;
      text-align: right;
      margin-left: 0;
      margin-right: 0;
      vertical-align: middle;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      white-space: nowrap;
    }
    #status-mid { display: none; }
.header-date {
  margin: 0 6px;
  font-size: 7pt;
  font-family: ui-monospace, Menlo, Consolas, monospace;
  color: #f6f6ef !important;
  white-space: nowrap;
  text-decoration: none;
}
.header-date:visited { color: #f6f6ef !important; text-decoration: none; }
.header-date:hover { text-decoration: none; }
    .thread-hidden { display: none; }
    .togg {
      color: #828282;
      text-decoration: none;
      margin-left: 4px;
      font-size: 8pt;
    }
    .yclinks {
      font-size: 8pt;
      color: #828282;
      text-align: center;
      padding: 10px 0 20px 0;
    }
    .yclinks a { color: #828282; margin: 0 5px; }
    .yclinks a:hover { text-decoration: none; }
    .footer-info { text-align: center; margin-bottom: 6px; }
    .stealth-link { color: inherit; text-decoration: none; cursor: pointer; }
    .stealth-link:hover { text-decoration: none; }
    .record-table {
      border-collapse: collapse;
      width: 100%;
      background: #f6f6ef;
      border: 1px solid #9a9a9a;
    }
    .record-table td {
      border: 1px solid #9a9a9a;
      padding: 6px 8px;
      vertical-align: top;
    }
    .record-label {
      width: 140px;
      color: #828282;
      font-size: 8pt;
      background: #efefe3;
    }
    .archive-table {
      border-collapse: collapse;
      width: 100%;
      background: #f6f6ef;
      border: 1px solid #9a9a9a;
    }
    .archive-table th, .archive-table td {
      border: 1px solid #9a9a9a;
      padding: 6px 8px;
      text-align: left;
      font-size: 8pt;
    }
    .archive-table th {
      background: #efefe3;
      font-weight: bold;
    }
    .db-icon, .doc-icon {
      display: inline-block;
      width: 10px;
      height: 10px;
      margin-right: 6px;
      vertical-align: middle;
      border: 1px solid #9a9a9a;
      background: #d9d9d9;
    }
    .db-icon { border-radius: 2px; box-shadow: inset 0 -2px 0 #bdbdbd; }
    .doc-icon { border-radius: 1px; background: #efefe3; }
    .archive-chart {
      width: 100%;
      height: 220px;
      background: #f6f6ef;
      border: 1px solid #9a9a9a;
      margin-top: 10px;
      margin-bottom: 16px;
      padding-bottom: 6px;
      box-sizing: border-box;
    }
    .archive-chart.pad-bottom {
      padding-bottom: 10px;
    }
    .warp-input {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 10pt;
      border: 1px solid #828282;
      padding: 2px;
      text-align: right;
    }
    .warp-input.top {
      font-size: 8pt;
      padding: 1px 2px;
      width: 120px;
    }
    .warp-form {
      text-align: center;
      margin: 6px 0 12px 0;
    }
    .warp-form.top {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin: 0;
    }
    .time-step {
      font-family: Verdana, Geneva, sans-serif;
      font-size: 10pt;
      border: 1px solid #828282;
      background: #f6f6ef;
      color: #828282;
      padding: 1px 6px;
      margin: 0 4px;
      cursor: pointer;
    }
    .logo-box {
      width: 20px;
      height: 20px;
      border: 1px solid #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      vertical-align: middle;
    }
    .logo-icon { width: 16px; height: 16px; image-rendering: pixelated; display: block; }
    .query-input {
      width: 100%;
      min-height: 140px;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 10pt;
      border: 1px solid #9a9a9a;
      background: #f6f6ef;
      padding: 8px;
      box-sizing: border-box;
    }
    .query-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
    }
    .query-run {
      font-weight: bold;
      border-color: #111;
      box-shadow: inset 0 0 0 1px #fff;
    }
    .query-shards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
      gap: 0;
      margin-top: 8px;
      max-height: 160px;
      overflow: auto;
      padding: 0;
      border: 1px solid #9a9a9a;
      background: #f6f6ef;
      font-size: 8pt;
      justify-items: stretch;
      align-items: stretch;
    }
    .query-shards label {
      white-space: nowrap;
      border-right: 1px solid #e0e0d6;
      border-bottom: 1px solid #e0e0d6;
      padding: 4px 6px;
      background: #f9f9f2;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .query-shards-actions { display: flex; align-items: center; gap: 6px; margin-top: 6px; }
    .query-output {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 9pt;
      background: #f6f6ef;
      border: 1px solid #9a9a9a;
      padding: 8px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .schema-block {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-size: 9pt;
      background: #f6f6ef;
      border: 1px solid #9a9a9a;
      padding: 8px;
      white-space: pre-wrap;
    }
    @media (max-width: 1200px) {
      .status-cell { width: auto; white-space: normal; }
      .header-right {
        display: grid;
        grid-template-columns: 1fr auto;
        grid-template-rows: auto auto auto;
        justify-items: end;
        row-gap: 4px;
        column-gap: 8px;
      }
      .date-row { display: contents; }
      .header-date { grid-row: 1; grid-column: 1 / -1; margin: 0; }
      .warp-form.top { grid-row: 2; grid-column: 1 / -1; }
      .archive-badge-link { grid-row: 3; grid-column: 2; }
      #status-right { grid-row: 3; grid-column: 1; justify-self: end; margin-right: 3px; }
    }
    /* Mobile: smaller indents */
    @media (max-width: 600px) {
      body { font-size: 12px; }
      .pagetop, .title { font-size: 12px; line-height: 1.4; }
      .subtext, .comhead { font-size: 10px; line-height: 1.3; }
      .commtext { font-size: 12px; line-height: 1.5; }
      .ind { transform: scaleX(0.5); transform-origin: left; }
      .commtext { max-width: 100%; margin-right: 10px; }
      #hnmain { width: 100% !important; }
      #status-right { display: none; }
      #status-mid { display: block; width: 100%; margin-top: 2px; }
      .status-cell { width: auto; }
      .topbar > table { display: block; width: 100%; }
      .topbar > table > tbody > tr {
        display: flex;
        align-items: flex-start;
        gap: 8px;
      }
      .topbar > table > tbody > tr > td { display: block; }
      .nav-cell { flex: 1 1 auto; min-width: 0; }
      .status-cell { flex: 0 0 auto; }
      .nav-wrap { flex-wrap: wrap; }
      .pagetop { display: block; }
      .header-right { flex-direction: column; align-items: flex-end; gap: 4px; }
      .header-date { order: 1; display: block; margin: 0; }
      .warp-form.top { order: 2; }
      .archive-badge-link { order: 3; }
      .archive-badge { order: 3; }
      .warp-input, .time-step { font-size: 16px; }
      .warp-input.top { width: 140px; }
      .footer-info { text-align: center; font-size: 10px; }
      .yclinks { font-size: 10px; padding-bottom: 12px; }
      .nav-wrap { flex-wrap: wrap; }
    }
    .u-legend {
      margin-top: 4px;
    }
  </style>

</head>
<body>
<center>
  <table id="hnmain" border="0" cellpadding="0" cellspacing="0" width="85%">
    <tr>
      <td class="topbar">
        <table border="0" cellpadding="0" cellspacing="0" width="100%" style="padding:2px">
          <tr>
            <td style="width:18px;padding-right:4px; vertical-align:middle;">
              <a href="#" id="logo-link" title="Seize the random day" onclick="return false;"><span class="logo-box"><img src="cd.png" alt="" class="logo-icon" title="Archive"></span></a>
            </td>
            <td class="nav-cell">
              <div class="nav-wrap">
                <span class="pagetop">
                  <b class="hnname"><a href="?view=news" data-spa id="home-link" title="Go to the most recent snapshot">Hacker Book</a></b>
                  <a href="?view=newest" data-spa>new</a> |
                  <a href="?view=news" data-spa>front</a> |
                  <a href="#" id="start-link" title="Go to the first day">start</a> |
                  <a href="?view=ask" data-spa>ask</a> |
                  <a href="?view=show" data-spa>show</a> |
                  <a href="?view=jobs" data-spa>jobs</a> |
                  <a href="?view=query" data-spa>query</a>
                  <span id="status-mid"></span>
                </span>
              </div>
            </td>
            <td class="status-cell" style="text-align:right;padding-right:6px; vertical-align:middle;">
              <span class="header-right">
                <span class="date-row">
                  <span id="status-right" class="pagetop"></span>
                  <a id="header-date" class="pagetop header-date" href="?view=news" data-spa>Someday, Month 00, 0000</a>
                </span>
                <form class="warp-form top" onsubmit="return false;">
                  <button class="time-step" type="button" data-step="-1" title="Back 1 day">&lt;</button>
                  <input type="date" id="warp-date-top" class="warp-input top warp-date" title="Choose your day">
                  <button class="time-step" type="button" data-step="1" title="Forward 1 day">&gt;</button>
                </form>
                <a class="archive-badge-link" href="?view=archive" data-spa title="Archive Stats and Graph"><span class="archive-badge">ARCHIVE</span></a>
              </span>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <tr style="height:10px"></tr>

    <tr>
      <td>
        <table border="0" cellpadding="0" cellspacing="0" class="itemlist" id="content-table">
          <tr><td style="padding:14px" class="loading">Loading…</td></tr>
        </table>
      </td>
    </tr>

    <tr><td><div class="hr"></div></td></tr>

    <tr>
      <td class="yclinks">
        <a href="https://www.ycombinator.com">Y Combinator</a>|<a href="https://www.ycombinator.com/apply/">Apply</a>|<a href="https://www.ycombinator.com/companies/">Companies</a>|<a href="https://www.ycombinator.com/blog/">Blog</a>|<a href="https://news.ycombinator.com">Live HN</a>
        |<a href="mailto:hey@browserbox.io">Contact</a>
      </td>
    </tr>
    <tr>
      <td>
        <form class="warp-form" onsubmit="return false;">
          <button class="time-step" type="button" data-step="-1" title="Back 1 day">&lt;</button>
          <input type="date" id="warp-date" class="warp-input warp-date" title="Choose your day">
          <button class="time-step" type="button" data-step="1" title="Forward 1 day">&gt;</button>
        </form>
      </td>
    </tr>
    <tr>
      <td style="padding: 0 10px 12px 10px;">
        <div class="subtext footer-info">
          Viewing HN on <span id="snapInfo">Someday, Month 00, 0000</span>. Times are relative to 11:59 PM.
        </div>
        <div class="subtext footer-info" id="statsInfo"></div>
        <div class="subtext footer-info">
          Made by <a class="stealth-link" href="https://github.com/DOSAYGO-STUDIO">DOSAYGO</a> · <a class="stealth-link" href="https://dosaygo-studio.github.io/HackerBook/">[GET THIS]</a>
        </div>
      </td>
    </tr>
  </table>
</center>

<!-- Use the same sqlite wasm you already ship in primes -->
<script src="jswasm/sqlite3.js"></script>
<script src="vendor/uplot/uPlot.iife.min.js"></script>

<script>
(() => {
  // -----------------------
  // Config
  // -----------------------
  const PATHS = {
    manifest: 'static-manifest.json.gz?v=20251230',
    archiveIndex: 'archive-index.json.gz?v=20251230',
    crossIndex: 'cross-shard-index.bin.gz?v=20251230',
    userStatsManifest: 'static-user-stats-manifest.json.gz?v=20251230'
  };

  const ITEMS_PER_PAGE = 30;
  const LIST_SHARDS_TO_SCAN = 1;        // soft-launch behavior until you add real frontpage snapshots
  const SHARD_CACHE_LIMIT = 10;
  const SCORE_SORT_HORIZON_DAYS = 1;
  const COLLAPSE_STORE_KEY = 'staticNewsCollapsedV1';
  const THREAD_CACHE_LIMIT = 1;
  const COMMENT_FLUSH_CHARS = 70000;
  const COMMENT_FLUSH_BATCH = 180;

  // -----------------------
  // State
  // -----------------------
  let sqlite3 = null;
  let manifest = null;
  let archiveIndex = null;
  let crossIndex = null;
  let crossIndexPromise = null;
  let userStatsManifest = null;
  const userStatsCache = new Map();
  const userStatsInFlight = new Map();
  let timeShards = [];
  let timeRange = { min: null, max: null };
  let timeControlsBound = false;
  let routeToken = 0;
  let currentThreadId = null;
  const threadCache = new Map();
  let warpDebounce = null;
  let warpAbort = null;
  let lastWarpTs = null;
  let lastWarpDirection = 0;
  let lastWarpSid = null;
  let listRetryKey = null;
  let listRetryCount = 0;
  const shardInFlight = new Map();
  const timeIndexBySid = new Map();

  const statusRightEl = document.getElementById('status-right');
  const statusMidEl = document.getElementById('status-mid');
  const snapInfoEl = document.getElementById('snapInfo');
    const headerDateEl = document.getElementById('header-date');
  const statsInfoEl = document.getElementById('statsInfo');
  const tableEl = document.getElementById('content-table');

  // sid -> db
  const shardCache = new Map();
  const collapsedIds = new Set();
  const postsBySid = new Map();
  let initialRoute = true;

  // -----------------------
  // Utilities
  // -----------------------
  let statusHoldUntil = 0;
  function setStatus(msg, force = false) {
    if (!force && statusHoldUntil && Date.now() < statusHoldUntil) {
      return;
    }
    const text = msg || '';
    if (!text) statusHoldUntil = 0;
    statusRightEl.textContent = text;
    statusMidEl.textContent = text;
  }

  function holdStatus(msg, ms = 2000) {
    statusHoldUntil = Date.now() + ms;
    setStatus(msg, true);
    setTimeout(() => {
      if (Date.now() >= statusHoldUntil && statusRightEl.textContent === msg) {
        setStatus('', true);
      }
    }, ms);
  }

  function clearStatus(msg = '') {
    statusHoldUntil = 0;
    setStatus(msg, true);
  }

  function setReferenceTime(ts, updateHeader = true) {
    const next = Number(ts) || 0;
    currentReferenceTime = next;
    if (!updateHeader || !next) return;
    const d = new Date(next * 1000);
    const label = d.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric', timeZone: 'UTC' });
    const title = `You are viewing HN at ${label}. All times are relative to 11:59 PM that day.`;
    snapInfoEl.textContent = label;
    snapInfoEl.title = title;
    headerDateEl.textContent = label;
    headerDateEl.title = title;
  }

  function getWarpInputs() {
    return Array.from(document.querySelectorAll('.warp-date'));
  }

  function setWarpInputs(value) {
    getWarpInputs().forEach(input => { input.value = value; });
  }

  function qs() { return new URLSearchParams(location.search); }

  function nav(params) {
    const url = new URL(location.href);
    for (const [k,v] of Object.entries(params)) {
      if (v === null || v === undefined) url.searchParams.delete(k);
      else url.searchParams.set(k, String(v));
    }
    if (!('warp' in params) && qs().get('warp')) url.searchParams.set('warp', qs().get('warp'));
    if (!('warp_date' in params) && qs().get('warp_date')) url.searchParams.set('warp_date', qs().get('warp_date'));
    history.pushState(params, '', url.toString());
    route();
  }

  function cacheThread(id, html, resume = null) {
    if (!id || !html) return;
    if (threadCache.has(id)) threadCache.delete(id);
    threadCache.set(id, { html, scrollY: window.scrollY || 0, cachedAt: Date.now(), resume });
    while (threadCache.size > THREAD_CACHE_LIMIT) {
      const oldest = threadCache.keys().next().value;
      threadCache.delete(oldest);
    }
  }

  function restoreThreadFromCache(id) {
    const cached = threadCache.get(id);
    if (!cached) return false;
    tableEl.innerHTML = cached.html;
    applyCollapseState();
    requestAnimationFrame(() => {
      window.scrollTo(0, cached.scrollY || 0);
    });
    setStatus('');
    return true;
  }

  function saveResumeState(id, resume) {
    if (!id) return;
    const cached = threadCache.get(id);
    if (cached) {
      cached.resume = resume;
    } else {
      cacheThread(id, tableEl.innerHTML, resume);
    }
  }

  function clearResumeStates() {
    for (const entry of threadCache.values()) {
      entry.resume = null;
    }
  }

  function enableSPA() {
    document.querySelectorAll('a[data-spa]').forEach(a => {
      if (a.dataset.spaBound) return;
      a.dataset.spaBound = '1';
      a.addEventListener('click', (e) => {
        e.preventDefault();
        const u = new URL(a.href);
        const cur = qs();
        if (!u.searchParams.get('warp') && cur.get('warp')) u.searchParams.set('warp', cur.get('warp'));
        if (!u.searchParams.get('warp_date') && cur.get('warp_date')) u.searchParams.set('warp_date', cur.get('warp_date'));
        history.pushState({}, '', u.toString());
        route();
      });
    });
  }

  function decodeEntities(s) {
    if (!s) return '';
    return String(s)
      .replace(/&quot;/g, '"')
      .replace(/&#x27;/g, "'")
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&');
  }

  function fixFlatPreBlocks(html) {
    if (!html || html.includes('\n')) return html;
    return html.replace(/<pre><code>([\s\S]*?)<\/code><\/pre>/g, (m, body) => {
      if (body.includes('\n')) return m;
      const spaceRuns = body.match(/\s{2,}/g) || [];
      if (spaceRuns.length < 2) return m;
      let fixed = body.replace(/([^\n])(\s{2,})(?=\S)/g, (match, lead, spaces) => `${lead}\n${spaces}`);
      fixed = fixed.replace(/\/\n(\s*)\\/g, (match, spaces) => `/ ${spaces}\\`);
      fixed = fixed.replace(/\\\n(\s*)\//g, (match, spaces) => `\\${spaces}/`);
      if (fixed.startsWith('\n')) fixed = fixed.slice(1);
      return `<pre><code>${fixed}</code></pre>`;
    });
  }

  function hostFromUrl(url) {
    try { return new URL(url).host.replace(/^www\./,''); } catch { return ''; }
  }

  function userLinkHtml(username) {
    if (!username) return '';
    const byEsc = encodeURIComponent(username);
    return `<a class="hnuser" href="?view=user&id=${byEsc}" data-spa>${username}</a>`;
  }

  let currentReferenceTime = 0;

  function timeAgoSnapshot(ts) {
    const ref = currentReferenceTime
      || manifest?.snapshot_time
      || manifest?.shards?.reduce((m,s)=>Math.max(m, s.tmax||0), 0)
      || Math.floor(Date.now()/1000);
    if (!ts) return '';
    const seconds = Math.max(0, ref - ts);
    const minutes = Math.floor(seconds / 60);
    if (minutes < 1) return `${seconds}s ago`;
    const hours = Math.floor(minutes / 60);
    if (hours < 1) return `${minutes} minutes ago`;
    const days = Math.floor(hours / 24);
    if (days < 1) return `${hours} hours ago`;
    const months = Math.floor(days / 30);
    if (months < 1) return `${days} days ago`;
    const years = Math.floor(days / 365);
    if (years < 1) return `${months} months ago`;
    return `${years} years ago`;
  }

  function formatAbsoluteTime(ts) {
    if (!ts) return '';
    const d = new Date(ts * 1000);
    return d.toLocaleString('en-US', {
      weekday: 'long',
      month: 'long',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  }

  function toISODate(ts) {
    return new Date(ts * 1000).toISOString().split('T')[0];
  }

  function parseISODateUTC(dateStr, endOfDay = false) {
    const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(dateStr || '');
    if (!m) return null;
    const y = Number(m[1]);
    const mo = Number(m[2]) - 1;
    const d = Number(m[3]);
    if (!Number.isFinite(y) || !Number.isFinite(mo) || !Number.isFinite(d)) return null;
    const h = endOfDay ? 23 : 0;
    const min = endOfDay ? 59 : 0;
    const s = endOfDay ? 59 : 0;
    return Math.floor(Date.UTC(y, mo, d, h, min, s) / 1000);
  }

  function formatISODateUTC(ts) {
    const d = new Date(ts * 1000);
    const y = d.getUTCFullYear();
    const m = String(d.getUTCMonth() + 1).padStart(2, '0');
    const day = String(d.getUTCDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
  }

  function findShardForTs(targetTs) {
    const shards = manifest?.shards || [];
    let targetShard = shards.find(s => s.tmin <= targetTs && s.tmax >= targetTs);
    if (!targetShard && shards.length) {
      targetShard = shards.reduce((best, s) => {
        const dist = Math.min(Math.abs(s.tmin - targetTs), Math.abs(s.tmax - targetTs));
        const bestDist = Math.min(Math.abs(best.tmin - targetTs), Math.abs(best.tmax - targetTs));
        return dist < bestDist ? s : best;
      }, shards[0]);
    }
    return targetShard;
  }

  function navigateToWarpDate(dateStr) {
    if (!dateStr || !manifest) return;
    if (warpAbort) warpAbort.abort();
    warpAbort = new AbortController();
    let targetTs = parseISODateUTC(dateStr, false);
    if (!targetTs) return;
    if (timeRange.min && targetTs < timeRange.min) targetTs = timeRange.min;
    if (timeRange.max && targetTs > timeRange.max) targetTs = timeRange.max;
    const targetShard = findShardForTs(targetTs);
    if (targetShard) {
      if (lastWarpTs != null) lastWarpDirection = targetTs > lastWarpTs ? 1 : (targetTs < lastWarpTs ? -1 : 0);
      lastWarpTs = targetTs;
      lastWarpSid = targetShard.sid;
      const current = qs().get('view') || 'news';
      const view = ['news','newest','ask','show','jobs'].includes(current) ? current : 'news';
      const iso = formatISODateUTC(targetTs);
      setWarpInputs(iso);
      nav({ view, warp: targetShard.sid, warp_date: iso });
    }
  }

  function stepWarpDate(deltaDays) {
    const warpInput = getWarpInputs()[0];
    const baseTs = warpInput?.value
      ? parseISODateUTC(warpInput.value, false)
      : (currentReferenceTime || manifest?.snapshot_time || Math.floor(Date.now()/1000));
    if (!baseTs) return;
    let clampedBase = baseTs;
    if (timeRange.min && clampedBase < timeRange.min) clampedBase = timeRange.min;
    if (timeRange.max && clampedBase > timeRange.max) clampedBase = timeRange.max;
    if (clampedBase !== baseTs) {
      setWarpInputs(formatISODateUTC(clampedBase));
    }
    const nextTs = clampedBase + deltaDays * 86400;
    if (timeRange.min && nextTs < timeRange.min) {
      alert("Sorry, this archive cannot yet infer the existence of HN before HN existed.");
      return;
    }
    if (timeRange.max && nextTs > timeRange.max) {
      alert("Sorry this archive can not yet see the future.");
      return;
    }
    const next = formatISODateUTC(nextTs);
    setWarpInputs(next);
    navigateToWarpDate(next);
  }

  function formatExactRelative(ts, refTs) {
    if (!ts || !refTs) return '';
    let start = new Date(ts * 1000);
    let end = new Date(refTs * 1000);
    let suffix = 'ago';
    if (end < start) {
      [start, end] = [end, start];
      suffix = 'from now';
    }

    const startUTC = new Date(Date.UTC(
      start.getUTCFullYear(),
      start.getUTCMonth(),
      start.getUTCDate(),
      start.getUTCHours(),
      start.getUTCMinutes(),
      start.getUTCSeconds()
    ));
    const endUTC = new Date(Date.UTC(
      end.getUTCFullYear(),
      end.getUTCMonth(),
      end.getUTCDate(),
      end.getUTCHours(),
      end.getUTCMinutes(),
      end.getUTCSeconds()
    ));

    let years = endUTC.getUTCFullYear() - startUTC.getUTCFullYear();
    let candidate = new Date(startUTC);
    candidate.setUTCFullYear(startUTC.getUTCFullYear() + years);
    if (candidate > endUTC) {
      years -= 1;
      candidate = new Date(startUTC);
      candidate.setUTCFullYear(startUTC.getUTCFullYear() + years);
    }

    let months = endUTC.getUTCMonth() - candidate.getUTCMonth();
    if (months < 0) months += 12;
    candidate.setUTCMonth(candidate.getUTCMonth() + months);
    if (candidate > endUTC) {
      months -= 1;
      candidate.setUTCMonth(candidate.getUTCMonth() - 1);
    }

    let remainingMs = endUTC.getTime() - candidate.getTime();
    const days = Math.floor(remainingMs / 86400000);
    remainingMs -= days * 86400000;
    const hours = Math.floor(remainingMs / 3600000);
    remainingMs -= hours * 3600000;
    const minutes = Math.floor(remainingMs / 60000);
    remainingMs -= minutes * 60000;
    const seconds = Math.floor(remainingMs / 1000);

    const rawParts = [
      ['years', years],
      ['months', months],
      ['days', days],
      ['hours', hours],
      ['minutes', minutes],
      ['seconds', seconds]
    ];
    const firstIdx = rawParts.findIndex(([, val]) => val !== 0);
    const parts = rawParts
      .slice(firstIdx >= 0 ? firstIdx : rawParts.length - 1)
      .filter(([, val], idx, arr) => val !== 0 || arr.slice(idx + 1).some(([, v]) => v !== 0));
    if (!parts.length) return `0 seconds ${suffix}`;
    return `${parts.map(([label,val]) => `${val} ${label}`).join(', ')} ${suffix}`;
  }

  // -----------------------
  // Manifest routing: id -> shard record (binary search)
  // -----------------------
  function shardRecForId(id) {
    const x = Number(id);
    const shards = manifest?.shards || [];
    let lo = 0, hi = shards.length - 1;
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const s = shards[mid];
      if (x < s.id_lo) hi = mid - 1;
      else if (x > s.id_hi) lo = mid + 1;
      else return s;
    }
    return null;
  }

  // -----------------------
  // Shard loading (.sqlite or .sqlite.gz) + deserialize
  // -----------------------
  async function fetchBytes(url, signal = null) {
    try {
      const r = await fetch(url, { cache: 'force-cache', signal });
      if (!r.ok) throw new Error(`fetch failed ${r.status}: ${url}`);
      return new Uint8Array(await r.arrayBuffer());
    } catch (err) {
      if (err && err.name === 'AbortError') return new Uint8Array();
      throw err;
    }
  }

  async function maybeGunzip(u8) {
    // gzip header 1f 8b
    if (u8.length >= 2 && u8[0] === 0x1f && u8[1] === 0x8b) {
      if (typeof DecompressionStream !== 'undefined') {
        const ds = new DecompressionStream('gzip');
        const stream = new Response(u8).body.pipeThrough(ds);
        const buf = await new Response(stream).arrayBuffer();
        return new Uint8Array(buf);
      }
      if (typeof pako !== 'undefined') {
        return pako.ungzip(u8);
      }
      throw new Error('gzip not supported in this browser');
    }
    return u8;
  }

  async function fetchJsonMaybeGzip(url, signal = null) {
    const u8 = await fetchBytes(url, signal);
    if (!u8 || u8.length === 0) return null;
    const raw = await maybeGunzip(u8);
    const text = new TextDecoder('utf-8').decode(raw);
    return JSON.parse(text);
  }

  function parseCrossIndex(u8) {
    const buf = u8.buffer.slice(u8.byteOffset, u8.byteOffset + u8.byteLength);
    const view = new DataView(buf);
    const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1), view.getUint8(2), view.getUint8(3));
    if (magic !== 'CSHX') throw new Error('cross index: bad magic');
    const version = view.getUint32(4, true);
    if (version !== 1) throw new Error(`cross index: unsupported version ${version}`);
    const parentsCount = view.getUint32(8, true);
    const linksCount = view.getUint32(12, true);
    const headerBytes = 24;
    let offset = headerBytes;
    const parentIds = new Uint32Array(buf, offset, parentsCount);
    offset += parentsCount * 4;
    const offsets = new Uint32Array(buf, offset, parentsCount + 1);
    offset += (parentsCount + 1) * 4;
    const shardSids = new Uint16Array(buf, offset, linksCount);
    return { parentIds, offsets, shardSids };
  }

  function findCrossShardSids(parentId) {
    if (!crossIndex) return null;
    const ids = crossIndex.parentIds;
    let lo = 0;
    let hi = ids.length - 1;
    const target = Number(parentId);
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const v = ids[mid];
      if (target < v) hi = mid - 1;
      else if (target > v) lo = mid + 1;
      else {
        const start = crossIndex.offsets[mid];
        const end = crossIndex.offsets[mid + 1];
        return crossIndex.shardSids.subarray(start, end);
      }
    }
    return null;
  }

  async function loadCrossIndex() {
    if (crossIndexPromise) return crossIndexPromise;
    crossIndexPromise = (async () => {
      try {
        const u8 = await fetchBytes(PATHS.crossIndex);
        if (!u8 || u8.length === 0) return null;
        const raw = await maybeGunzip(u8);
        crossIndex = parseCrossIndex(raw);
        return crossIndex;
      } catch (err) {
        console.warn('cross index load failed', err);
        return null;
      }
    })();
    return crossIndexPromise;
  }

  async function loadShardBySid(sid) {
    if (shardCache.has(sid)) return shardCache.get(sid);
    if (shardInFlight.has(sid)) return shardInFlight.get(sid);

    const rec = (manifest.shards || []).find(s => s.sid === sid);
    if (!rec) throw new Error(`Unknown shard sid=${sid}`);

    setStatus(`loading file…`);
    const promise = (async () => {
      try {
        const u8 = await fetchBytes('static-shards/' + rec.file, warpAbort ? warpAbort.signal : null);
        if (!u8 || u8.length === 0) return null;
        const raw = await maybeGunzip(u8);
        if (warpAbort && warpAbort.signal.aborted) return null;

        const p = sqlite3.wasm.allocFromTypedArray(raw);
        const db = new sqlite3.oo1.DB();
        sqlite3.capi.sqlite3_deserialize(
          db.pointer, "main", p, raw.byteLength, raw.byteLength,
          sqlite3.capi.SQLITE_DESERIALIZE_FREEONCLOSE
        );

        shardCache.set(sid, db);
        // cache eviction
        if (shardCache.size > SHARD_CACHE_LIMIT) {
          const oldest = shardCache.keys().next().value;
          try { shardCache.get(oldest).close(); } catch {}
          shardCache.delete(oldest);
        }

        return db;
      } finally {
        shardInFlight.delete(sid);
        setStatus('');
      }
    })();

    shardInFlight.set(sid, promise);
    return promise;
  }

  async function loadUserStatsManifest() {
    if (userStatsManifest) return userStatsManifest;
    userStatsManifest = await fetchJsonMaybeGzip(PATHS.userStatsManifest);
    if (userStatsManifest?.shards) {
      userStatsManifest.shards = userStatsManifest.shards.slice().sort((a, b) => {
        const al = String(a.user_lo || '');
        const bl = String(b.user_lo || '');
        return al.localeCompare(bl);
      });
    }
    return userStatsManifest;
  }

  function normalizeUser(name) {
    return String(name || '').trim().toLowerCase();
  }

  function findUserShard(name, shards) {
    const target = normalizeUser(name);
    let lo = 0;
    let hi = shards.length - 1;
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      const s = shards[mid];
      const loName = String(s.user_lo || '');
      const hiName = String(s.user_hi || '');
      if (target < loName) hi = mid - 1;
      else if (target > hiName) lo = mid + 1;
      else return s;
    }
    return null;
  }

  async function loadUserStatsShardRec(rec) {
    if (!rec) return null;
    const sid = rec.sid;
    if (userStatsCache.has(sid)) return userStatsCache.get(sid);
    if (userStatsInFlight.has(sid)) return userStatsInFlight.get(sid);

    const promise = (async () => {
      try {
        const u8 = await fetchBytes('static-user-stats-shards/' + rec.file);
        if (!u8 || u8.length === 0) return null;
        const raw = await maybeGunzip(u8);
        const p = sqlite3.wasm.allocFromTypedArray(raw);
        const db = new sqlite3.oo1.DB();
        sqlite3.capi.sqlite3_deserialize(
          db.pointer, "main", p, raw.byteLength, raw.byteLength,
          sqlite3.capi.SQLITE_DESERIALIZE_FREEONCLOSE
        );
        userStatsCache.set(sid, db);
        if (userStatsCache.size > 5) {
          const oldest = userStatsCache.keys().next().value;
          try { userStatsCache.get(oldest).close(); } catch {}
          userStatsCache.delete(oldest);
        }
        return db;
      } finally {
        userStatsInFlight.delete(sid);
      }
    })();

    userStatsInFlight.set(sid, promise);
    return promise;
  }

  async function loadUserStatsShard(username) {
    const manifest = await loadUserStatsManifest();
    if (!manifest) return null;
    const rec = findUserShard(username, manifest.shards || []);
    if (!rec) return null;
    return loadUserStatsShardRec(rec);
  }

  async function loadUserStatsShardBySid(sid) {
    const manifest = await loadUserStatsManifest();
    if (!manifest) return null;
    const rec = (manifest.shards || []).find(s => s.sid === sid);
    if (!rec) return null;
    return loadUserStatsShardRec(rec);
  }

  // -----------------------
  // SQL helpers
  // -----------------------
  function sqlAll(db, sql, bind=[]) {
    return db.exec({ sql, bind, rowMode:'object', returnValue:'resultRows' }) || [];
  }
  function sqlOne(db, sql, bind=[]) {
    const rows = sqlAll(db, sql, bind);
    return rows[0] || null;
  }

  const QUERY_RE = {
    trailingSemis: /;+\s*$/g,
    leadingSelect: /^(select|with)\b/i,
    disallowed: /(\bpragma\b|\battach\b|\bdetach\b|\bdrop\b|\balter\b|\bupdate\b|\binsert\b|\bdelete\b|\bcreate\b|\bvacuum\b)/i,
    limit: /\blimit\b/i,
    limitValue: /limit\s+(\d+)/i,
    orderBy: /order\s+by\s+([\s\S]+?)(?:\blimit\b|$)/i
  };

  function isSafeQuery(sql) {
    const s = String(sql || '').trim().replace(/;+\s*$/g, '');
    if (!s) return false;
    if (!QUERY_RE.leadingSelect.test(s)) return false;
    if (QUERY_RE.disallowed.test(s)) return false;
    return true;
  }

  function getLimit(sql) {
    const s = String(sql || '').trim().replace(QUERY_RE.trailingSemis, '');
    const m = QUERY_RE.limitValue.exec(s);
    return m ? Number(m[1]) : null;
  }

  function addLimitIfMissing(sql, maxRows) {
    const s = String(sql || '').trim().replace(QUERY_RE.trailingSemis, '');
    if (QUERY_RE.limit.test(s)) return s;
    return `${s} LIMIT ${maxRows}`;
  }

  function parseOrderBy(sql) {
    const s = String(sql || '').trim().replace(QUERY_RE.trailingSemis, '');
    const m = QUERY_RE.orderBy.exec(s);
    if (!m) return [];
    return m[1]
      .split(',')
      .map(part => part.trim())
      .filter(Boolean)
      .map(part => {
        const bits = part.split(/\s+/);
        const key = bits[0].replace(/[`\"]/g, '');
        const dir = (bits[1] || 'asc').toLowerCase() === 'desc' ? 'desc' : 'asc';
        return { key, dir };
      });
  }

  function sortRows(rows, order) {
    if (!order || !order.length) return rows;
    const dirVal = dir => (dir === 'desc' ? -1 : 1);
    rows.sort((a, b) => {
      for (const o of order) {
        const av = a[o.key];
        const bv = b[o.key];
        if (av == null && bv == null) continue;
        if (av == null) return 1;
        if (bv == null) return -1;
        if (typeof av === 'number' && typeof bv === 'number') {
          const diff = av - bv;
          if (diff !== 0) return diff * dirVal(o.dir);
        } else {
          const diff = String(av).localeCompare(String(bv));
          if (diff !== 0) return diff * dirVal(o.dir);
        }
      }
      return 0;
    });
    return rows;
  }

  // -----------------------
  // List views (soft launch)
  // -----------------------
  function rebuildTimeIndex() {
    const effMap = new Map((archiveIndex?.shards || []).map(s => [s.sid, s]));
    postsBySid.clear();
    (archiveIndex?.shards || []).forEach(s => postsBySid.set(s.sid, s.posts || 0));
    timeShards = (manifest?.shards || []).map(s => {
      const eff = effMap.get(s.sid);
      return {
        sid: s.sid,
        tmin: eff?.tmin_eff || s.tmin_eff || s.tmin || 0,
        tmax: eff?.tmax_eff || s.tmax_eff || s.tmax || 0
      };
    }).sort((a,b)=> (a.tmax||0) - (b.tmax||0) || (a.tmin||0) - (b.tmin||0));
    timeIndexBySid.clear();
    timeShards.forEach((s, i) => timeIndexBySid.set(s.sid, i));
    if (timeShards.length) {
      const minTs = timeShards[0].tmin || null;
      const maxTs = timeShards[timeShards.length - 1].tmax || null;
      timeRange.min = minTs ? parseISODateUTC(formatISODateUTC(minTs), false) : null;
      timeRange.max = maxTs ? parseISODateUTC(formatISODateUTC(maxTs), true) : null;
      getWarpInputs().forEach(input => {
        if (timeRange.min) input.min = toISODate(timeRange.min);
        if (timeRange.max) input.max = toISODate(timeRange.max);
      });
    }
  }

  function latestShardSids(n) {
    const shards = timeShards || [];
    return shards.slice(-n).map(s => s.sid).reverse();
  }

  function findFirstShardWithPosts() {
    if (!timeShards.length) return null;
    for (const shard of timeShards) {
      if ((postsBySid.get(shard.sid) || 0) > 0) return shard;
    }
    return timeShards[0];
  }

  function findNextShardWithPosts(startSid) {
    if (!timeIndexBySid.has(startSid)) return null;
    const idx = timeIndexBySid.get(startSid);
    for (let i = idx; i < timeShards.length; i++) {
      const shard = timeShards[i];
      if ((postsBySid.get(shard.sid) || 0) > 0) return shard;
    }
    for (let i = idx - 1; i >= 0; i--) {
      const shard = timeShards[i];
      if ((postsBySid.get(shard.sid) || 0) > 0) return shard;
    }
    return timeShards[idx];
  }

  async function listView(view, page, warpSid = null, warpDate = null, token = 0) {
    const offset = (page - 1) * ITEMS_PER_PAGE;
    const scoreSortViews = new Set(['news', 'ask', 'show', 'jobs']);
    const isScoreSorted = scoreSortViews.has(view);

    const referenceTime = warpDate
      ? parseISODateUTC(warpDate, true)
      : (warpSid !== null
        ? ((timeIndexBySid.has(warpSid) ? timeShards[timeIndexBySid.get(warpSid)]?.tmax : null) || manifest.snapshot_time)
        : manifest.snapshot_time);
    const cutoff = referenceTime ? (referenceTime - SCORE_SORT_HORIZON_DAYS * 86400) : 0;

    // If warped to a specific date, scan shards in the time window
    // Otherwise use the shard index with a small radius
    let sids;
    if (warpDate && referenceTime) {
      const inWindow = timeShards.filter(s => (s.tmax || 0) >= cutoff && (s.tmin || 0) <= referenceTime);
      sids = inWindow.map(s => s.sid).reverse();
    } else if (warpSid !== null) {
      const radius = 4;
      const idx = timeIndexBySid.has(warpSid) ? timeIndexBySid.get(warpSid) : -1;
      const base = idx >= 0 ? idx : Math.max(0, timeShards.length - 1);
      const lo = Math.max(0, base - radius);
      const hi = Math.min(timeShards.length - 1, base + radius);
      sids = [];
      for (let i = hi; i >= lo; i--) sids.push(timeShards[i].sid);
    } else {
      sids = latestShardSids(LIST_SHARDS_TO_SCAN);
    }

    clearStatus();
    setStatus(`loading ${view}${warpSid !== null ? ' (warped)' : ''}…`);

    let all = [];

    for (const sid of sids) {
      if (token && token !== routeToken) return;
      const db = await loadShardBySid(sid);
      if (!db) continue;

      let where = `type='story'`;
      let order = `ORDER BY time DESC`;

      if (view === 'news') order = `ORDER BY score DESC, time DESC`;
      if (view === 'newest') order = `ORDER BY time DESC`;
      if (view === 'ask') where += ` AND (title LIKE 'Ask HN:%' OR title LIKE 'Ask HN %')`;
      if (view === 'show') where += ` AND (title LIKE 'Show HN:%' OR title LIKE 'Show HN %')`;
      if (view === 'jobs') where = `type='job'`;
      if (isScoreSorted && cutoff) where += ` AND time >= ${cutoff}`;
      if (warpDate && referenceTime) where += ` AND time <= ${referenceTime}`;
      if (isScoreSorted && view !== 'news') order = `ORDER BY score DESC, time DESC`;

      const rows = sqlAll(db, `
        SELECT id,type,by,time,title,url,score
        FROM items
        WHERE ${where}
        ${order}
        LIMIT 250
      `);

      all.push(...rows);

      if (all.length > offset + ITEMS_PER_PAGE + 300) break;
    }

    if (isScoreSorted) all.sort((a,b) => (b.score||0)-(a.score||0) || (b.time||0)-(a.time||0));
    else all.sort((a,b) => (b.time||0)-(a.time||0));

    const pageRows = all.slice(offset, offset + ITEMS_PER_PAGE);

    // Get comment counts (direct children only - shows as "N+ comments")
    const commentCounts = new Map();
    const storyIds = pageRows.map(r => r.id);
    for (const sid of sids) {
      if (token && token !== routeToken) return;
      const db = await loadShardBySid(sid);
      if (!db) continue;
      const ids = storyIds.join(',');
      if (ids) {
        const counts = sqlAll(db, `
          SELECT parent_id, COUNT(*) as cnt FROM edges
          WHERE parent_id IN (${ids})
          GROUP BY parent_id
        `);
        for (const c of counts) {
          commentCounts.set(c.parent_id, (commentCounts.get(c.parent_id) || 0) + c.cnt);
        }
      }
    }

    if (token && token !== routeToken) return;
    const retryKey = `${view}|${page}|${warpSid ?? ''}|${warpDate ?? ''}`;
    if (!pageRows.length) {
      const labelMap = { news: 'front', newest: 'new', ask: 'ask', show: 'show', jobs: 'jobs' };
      const label = labelMap[view] || view;
      const titled = label.charAt(0).toUpperCase() + label.slice(1);
      const noItemsMsg = view !== 'news' ? `No ${titled} for this day.` : 'No more items for this day.';

      // Avoid wiping the current view if a warp is still resolving or aborted.
      if (warpAbort && warpAbort.signal && warpAbort.signal.aborted) {
        setStatus('');
        return;
      }

      if (initialRoute && (view !== 'news' || page > 1)) {
        nav({ view: 'news', p: 1, warp: warpSid, warp_date: warpDate, id: null });
        return;
      }
      if ((warpDate || warpSid !== null) && (view !== 'news' || page > 1)) {
        holdStatus(noItemsMsg, 2000);
      }
      if (listRetryKey !== retryKey) {
        listRetryKey = retryKey;
        listRetryCount = 0;
      }
      if (listRetryCount < 2) {
        listRetryCount += 1;
        setTimeout(() => {
          if (token !== routeToken) return;
          const p = qs();
          const curView = p.get('view') || 'news';
          const curPage = Math.max(1, parseInt(p.get('p') || '1', 10));
          const curWarp = p.get('warp') ? parseInt(p.get('warp'), 10) : null;
          const curWarpDate = p.get('warp_date');
          if (`${curView}|${curPage}|${curWarp ?? ''}|${curWarpDate ?? ''}` === retryKey) {
            listView(curView, curPage, curWarp, curWarpDate, token);
          }
        }, 250);
        if (warpDate || warpSid !== null) {
          holdStatus(noItemsMsg, 2000);
        } else {
          setStatus('Loading…');
        }
        return;
      }
      if (warpDate || warpSid !== null) {
        const refSid = warpSid ?? findShardForTs(referenceTime)?.sid;
        if (refSid != null) {
          const fallback = findNextShardWithPosts(refSid);
          if (fallback && fallback.sid !== refSid) {
            const iso = formatISODateUTC(fallback.tmin || fallback.tmax || referenceTime);
            setWarpInputs(iso);
            nav({ view: 'news', p: 1, warp: fallback.sid, warp_date: iso, id: null });
            return;
          }
        }
        holdStatus(noItemsMsg, 2000);
      }
      if (tableEl && tableEl.innerHTML && !tableEl.innerHTML.includes('Loading')) {
        holdStatus(noItemsMsg, 2000);
        return;
      }
    } else {
      listRetryKey = null;
      listRetryCount = 0;
    }
    if (referenceTime) setReferenceTime(referenceTime, true);
    clearStatus();
    renderList(pageRows, view, page, offset, commentCounts);

    if (lastWarpSid != null && lastWarpDirection !== 0) {
      prefetchAdjacentShard(lastWarpSid, lastWarpDirection);
    }

    if (!statusHoldUntil || Date.now() >= statusHoldUntil) {
      setStatus('');
    }
  }

  function prefetchAdjacentShard(sid, direction) {
    if (!timeIndexBySid.has(sid)) return;
    const idx = timeIndexBySid.get(sid);
    const nextIdx = idx + (direction > 0 ? 1 : -1);
    if (nextIdx < 0 || nextIdx >= timeShards.length) return;
    const nextSid = timeShards[nextIdx].sid;
    if (shardCache.has(nextSid)) return;
    loadShardBySid(nextSid).catch(() => {});
  }

  function renderList(items, view, page, offset, commentCounts = new Map()) {
    let html = '';
    items.forEach((it, i) => {
      const rank = offset + i + 1;
      const title = decodeEntities(it.title || '[untitled]');
      const url = it.url ? decodeEntities(it.url) : `?view=item&id=${it.id}`;
      const site = it.url ? hostFromUrl(url) : '';
      const points = (it.score == null) ? '' : `${it.score} points`;
      const by = it.by || '';
      const byHtml = by ? userLinkHtml(by) : '';
      const age = timeAgoSnapshot(it.time);
      const cnt = commentCounts.get(it.id) || 0;
      const comments = cnt > 0 ? `${cnt}+ comments` : 'discuss';

      html += `
        <tr class="athing" id="${it.id}">
          <td align="right" valign="top" class="title"><span class="rank">${rank}.</span></td>
          <td valign="top" class="votelinks"><center><div class="archive-dot"></div></center></td>
          <td class="title">
            <span class="titleline">
              ${it.url
                ? `<a href="${url}">${title}</a>`
                : `<a href="?view=item&id=${it.id}" onclick="nav({view:'item',id:${it.id}});return false;">${title}</a>`}
              ${site ? `<span class="sitebit comhead"> (<span class="sitestr">${site}</span>)</span>` : ``}
            </span>
          </td>
        </tr>
        <tr>
          <td colspan="2"></td>
          <td class="subtext">
            <span class="subline">
              ${points ? `<span class="score" id="score_${it.id}">${points}</span>` : ``}
              ${by ? `by ${byHtml}` : ``}
              ${age ? `<span class="age"><a href="?view=item&id=${it.id}" onclick="nav({view:'item',id:${it.id}});return false;">${age}</a></span>` : ``}
              ${comments ? `| <a href="?view=item&id=${it.id}" onclick="nav({view:'item',id:${it.id}});return false;">${comments}</a>` : ``}
            </span>
          </td>
        </tr>
        <tr class="spacer"></tr>
      `;
    });

    const hasMore = items.length === ITEMS_PER_PAGE;
    if (hasMore) {
      html += `
        <tr class="morespace" style="height:10px"></tr>
        <tr><td colspan="2"></td><td class="title">
          <a href="?view=${view}&p=${page+1}" class="morelink" onclick="nav({view:'${view}',p:${page+1}});return false;">More</a>
        </td></tr>
      `;
    }

    tableEl.innerHTML = html || `<tr><td style="padding:14px" class="loading">No items.</td></tr>`;
  }

  // -----------------------
  // Thread view using OG edges table
  // -----------------------
  async function fetchItem(id) {
    const rec = shardRecForId(id);
    if (!rec) return null;
    const db = await loadShardBySid(rec.sid);
    if (!db) return null;
    return sqlOne(db, `SELECT * FROM items WHERE id=? LIMIT 1`, [Number(id)]);
  }

  async function fetchChildrenBatch(ids) {
    // Group by shard sid and fetch in IN (...) batches
    const bySid = new Map();
    for (const id of ids) {
      const rec = shardRecForId(id);
      if (!rec) continue;
      if (!bySid.has(rec.sid)) bySid.set(rec.sid, []);
      bySid.get(rec.sid).push(Number(id));
    }

    const out = new Map();
    for (const [sid, list] of bySid.entries()) {
      const db = await loadShardBySid(sid);
      if (!db) continue;
      const placeholders = list.map(()=>'?').join(',');
      const rows = sqlAll(db, `SELECT * FROM items WHERE id IN (${placeholders})`, list);
      for (const r of rows) out.set(r.id, r);
    }
    return out;
  }

  async function childIdsForParent(parentId) {
    const rec = shardRecForId(parentId);
    if (!rec) return [];
    const ids = [];

    const db = await loadShardBySid(rec.sid);
    if (db) {
      const rows = sqlAll(db, `
        SELECT child_id FROM edges
        WHERE parent_id=?
        ORDER BY ord ASC
      `, [Number(parentId)]);
      ids.push(...rows.map(r => Number(r.child_id)).filter(Number.isFinite));
    }

    const extraSids = findCrossShardSids(parentId);
    if (extraSids && extraSids.length) {
      for (const sid of extraSids) {
        if (sid === rec.sid) continue;
        const otherDb = await loadShardBySid(sid);
        if (!otherDb) continue;
        const rows = sqlAll(otherDb, `
          SELECT child_id FROM edges
          WHERE parent_id=?
          ORDER BY ord ASC
        `, [Number(parentId)]);
        ids.push(...rows.map(r => Number(r.child_id)).filter(Number.isFinite));
      }
    }

    return ids;
  }

  function renderThreadSkeleton(root) {
    const title = decodeEntities(root.title || '[untitled]');
    const url = root.url ? decodeEntities(root.url) : '';
    const by = root.by || '';
    const byHtml = by ? userLinkHtml(by) : '';
    const age = timeAgoSnapshot(root.time);
    const points = (root.score == null) ? '' : `${root.score} points`;
    const site = url ? hostFromUrl(url) : '';

    tableEl.innerHTML = `
      <tr id="bigbox"><td>
        <table class="fatitem" border="0">
          <tr class="athing submission" id="${root.id}">
            <td align="right" valign="top" class="title"><span class="rank"></span></td>
            <td valign="top" class="votelinks"><center><div class="archive-dot"></div></center></td>
            <td class="title">
              <span class="titleline">
                ${url ? `<a href="${url}">${title}</a>` : `<a href="#" onclick="return false;">${title}</a>`}
                ${site ? `<span class="sitebit comhead"> (${site})</span>` : ``}
              </span>
            </td>
          </tr>
          <tr><td colspan="2"></td>
            <td class="subtext">
              <span class="subline">
                ${points ? `<span class="score">${points}</span>` : ``}
                ${by ? `by ${byHtml}` : ``}
                ${age ? `<span class="age">${age}</span>` : ``}
              </span>
            </td>
          </tr>
          ${root.text ? `<tr><td colspan="2"></td><td><div class="commtext">${decodeEntities(root.text)}</div></td></tr>` : ``}
        </table>
        <div class="hr"></div>
        <div id="comments-root" class="loading" style="padding:8px">Loading comments…</div>
      </td></tr>
    `;
  }

  function commentRowHtml(c, indent) {
    const by = c.by || '';
    const byHtml = by ? userLinkHtml(by) : '';
    const age = timeAgoSnapshot(c.time);
    const text = c.text ? fixFlatPreBlocks(decodeEntities(c.text)) : '';
    const pad = indent * 40;

    return `
      <tr class="athing comtr" id="${c.id}" data-id="${c.id}" data-depth="${indent}">
        <td>
          <table border="0">
            <tr>
              <td class="ind" style="width:${pad}px"></td>
              <td valign="top" class="votelinks"><center><div class="archive-dot"></div></center></td>
              <td class="default">
                <div style="margin-top:2px; margin-bottom:-10px;">
                  <span class="comhead">
                    ${by ? byHtml : ``}
                    ${age ? `<span class="age"><a href="?view=comment&id=${c.id}" onclick="nav({view:'comment',id:${c.id}});return false;">${age}</a></span>` : ``}
                    <a class="togg" href="#" data-toggle-id="${c.id}" onclick="toggleThread(${c.id});return false;">[–]</a>
                  </span>
                </div><br>
                <div class="comment"><div class="commtext">${text || `<span class="loading">[deleted]</span>`}</div></div>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    `;
  }

  async function renderThread(id, token = 0) {
    currentThreadId = id;
    const cached = threadCache.get(id);
    const resuming = !!(cached && cached.resume && !cached.resume.done);
    if (resuming) {
      restoreThreadFromCache(id);
    } else if (restoreThreadFromCache(id)) {
      return;
    }
    if (!resuming) {
      setStatus('Loading item…');
      const root = await fetchItem(id);
      if (token && token !== routeToken) return;

      if (!root) {
        tableEl.innerHTML = `<tr><td style="padding:14px" class="loading">Item not found.</td></tr>`;
        setStatus('');
        return;
      }

      renderThreadSkeleton(root);
    }

    const commentsRoot = document.getElementById('comments-root');
    if (!commentsRoot) return;
    if (!resuming) {
      commentsRoot.textContent = 'Loading comments…';
    }
    setStatus('Loading comments…');

    const resumeState = resuming ? cached.resume : null;
    const seen = resumeState ? resumeState.seen : new Set();
    let html = resumeState ? resumeState.html : '';
    let pending = resumeState ? resumeState.pending : '';
    let processed = resumeState ? resumeState.processed : 0;
    const stack = resumeState ? resumeState.stack : [{ parentId: Number(id), indent: 0, kids: null, idx: 0, map: null }];

    async function flushPending() {
      if (!pending) return;
      await new Promise(r => requestAnimationFrame(() => r()));
      if (token && token !== routeToken) return;
      commentsRoot.classList.remove('loading');
      commentsRoot.innerHTML = `<table border="0" cellpadding="0" cellspacing="0" width="100%">${html}${pending}</table>`;
      html += pending;
      pending = '';
    }

    while (stack.length) {
      if (token && token !== routeToken) {
        saveResumeState(id, { stack, seen, html, pending, processed, done: false });
        return;
      }
      const frame = stack[stack.length - 1];
      if (!frame.kids) {
        const kids = await childIdsForParent(frame.parentId);
        if (token && token !== routeToken) {
          saveResumeState(id, { stack, seen, html, pending, processed, done: false });
          return;
        }
        if (!kids.length) {
          stack.pop();
          continue;
        }
        const batch = kids.filter(x => !seen.has(x));
        batch.forEach(x => seen.add(x));
        if (!batch.length) {
          stack.pop();
          continue;
        }
        const map = await fetchChildrenBatch(batch);
        if (token && token !== routeToken) {
          saveResumeState(id, { stack, seen, html, pending, processed, done: false });
          return;
        }
        frame.kids = kids;
        frame.map = map;
        frame.idx = 0;
      }

      if (frame.idx >= frame.kids.length) {
        stack.pop();
        continue;
      }

      const cid = frame.kids[frame.idx++];
      const c = frame.map.get(cid);
      if (c) {
        pending += commentRowHtml(c, frame.indent);
        processed++;
        if (pending.length > COMMENT_FLUSH_CHARS || processed % COMMENT_FLUSH_BATCH === 0) {
          await flushPending();
          if (token && token !== routeToken) {
            saveResumeState(id, { stack, seen, html, pending, processed, done: false });
            return;
          }
        }
      }
      stack.push({ parentId: cid, indent: frame.indent + 1, kids: null, idx: 0, map: null });
    }
    if (token && token !== routeToken) return;

    commentsRoot.classList.remove('loading');
    commentsRoot.innerHTML = (html + pending)
      ? `<table border="0" cellpadding="0" cellspacing="0" width="100%">${html}${pending}</table>`
      : `<div class="subtext" style="padding:8px">No comments.</div>`;

    applyCollapseState();
    setStatus('');
    cacheThread(id, tableEl.innerHTML, null);
  }

  // -----------------------
  // Comment archive view
  // -----------------------
  async function renderCommentView(id, token = 0) {
    setStatus('Loading comment…');
    const item = await fetchItem(id);
    if (token && token !== routeToken) return;

    if (!item) {
      tableEl.innerHTML = `<tr><td style="padding:14px" class="loading">Item not found.</td></tr>`;
      setStatus('');
      return;
    }

    const title = decodeEntities(item.title || '[comment]');
    const text = item.text ? fixFlatPreBlocks(decodeEntities(item.text)) : '';
    const by = item.by || '';
    const byHtml = by ? userLinkHtml(by) : '';
    const score = item.score != null ? Number(item.score) : null;
    const absTime = formatAbsoluteTime(item.time);
    const relTime = timeAgoSnapshot(item.time);
    const parent = item.parent ? Number(item.parent) : null;

    const warpRelative = formatExactRelative(item.time, currentReferenceTime || manifest?.snapshot_time || Math.floor(Date.now()/1000));
    const nowRelative = formatExactRelative(item.time, Math.floor(Date.now() / 1000));

    tableEl.innerHTML = `
      <tr><td style="padding:10px">
        <div class="subtext">Archive record</div>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <table class="record-table">
          <tr><td class="record-label">ID</td><td class="title">${item.id}</td></tr>
          ${item.type ? `<tr><td class="record-label">Type</td><td class="title">${item.type}</td></tr>` : ``}
          ${by ? `<tr><td class="record-label">Author</td><td class="title">${byHtml}</td></tr>` : ``}
          ${score != null ? `<tr><td class="record-label">Score</td><td class="title">${score}</td></tr>` : ``}
          ${relTime ? `<tr><td class="record-label">Relative (simple)</td><td class="title">${relTime}</td></tr>` : ``}
          ${warpRelative ? `<tr><td class="record-label">Relative (warp)</td><td class="title">${warpRelative}</td></tr>` : ``}
          ${nowRelative ? `<tr><td class="record-label">Relative (now)</td><td class="title">${nowRelative}</td></tr>` : ``}
          ${absTime ? `<tr><td class="record-label">Time</td><td class="title">${absTime}</td></tr>` : ``}
          ${parent ? `<tr><td class="record-label">Parent</td><td class="title"><a href="?view=item&id=${parent}" onclick="nav({view:'item',id:${parent}});return false;">${parent}</a></td></tr>` : ``}
          <tr><td class="record-label">Text</td><td>${text ? `<div class="commtext">${text}</div>` : `<span class="loading">[deleted]</span>`}</td></tr>
        </table>
      </td></tr>
    `;

    setStatus('');
  }

  // -----------------------
  // Thread collapsing
  // -----------------------
  function loadCollapsedState() {
    try {
      const raw = localStorage.getItem(COLLAPSE_STORE_KEY);
      if (!raw) return;
      const arr = JSON.parse(raw);
      if (Array.isArray(arr)) arr.forEach(id => collapsedIds.add(Number(id)));
    } catch {}
  }

  function persistCollapsedState() {
    try {
      const arr = Array.from(collapsedIds.values());
      localStorage.setItem(COLLAPSE_STORE_KEY, JSON.stringify(arr));
    } catch {}
  }

  function applyCollapseState() {
    const rows = Array.from(document.querySelectorAll('tr.athing.comtr'));
    let collapsedStack = [];

    for (const row of rows) {
      const depth = Number(row.dataset.depth || 0);
      const id = Number(row.dataset.id);

      while (collapsedStack.length && depth <= collapsedStack[collapsedStack.length - 1].depth) {
        collapsedStack.pop();
      }

      const isHidden = collapsedStack.length > 0;
      row.classList.toggle('thread-hidden', isHidden);

      if (collapsedIds.has(id)) {
        collapsedStack.push({ id, depth });
      }
    }

    document.querySelectorAll('[data-toggle-id]').forEach(el => {
      const id = Number(el.getAttribute('data-toggle-id'));
      el.textContent = collapsedIds.has(id) ? '[+]' : '[–]';
    });
  }

  function toggleThread(id) {
    const num = Number(id);
    if (collapsedIds.has(num)) collapsedIds.delete(num);
    else collapsedIds.add(num);
    persistCollapsedState();
    applyCollapseState();
  }

  // -----------------------
  // Archive view
  // -----------------------
  async function loadArchiveIndex() {
    if (archiveIndex) return archiveIndex;
    archiveIndex = await fetchJsonMaybeGzip(PATHS.archiveIndex);
    return archiveIndex;
  }

  function formatBytes(bytes) {
    if (!Number.isFinite(bytes)) return '';
    const gb = bytes / (1024 ** 3);
    if (gb >= 1) return `${gb.toFixed(1)} GB`;
    const mb = bytes / (1024 ** 2);
    if (mb >= 1) return `${mb.toFixed(1)} MB`;
    const kb = bytes / 1024;
    return `${kb.toFixed(0)} KB`;
  }

  function formatDateShort(ts) {
    if (!ts) return '';
    return new Date(ts * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric', timeZone: 'UTC' });
  }

  function setupArchiveChart(shards) {
    const target = document.getElementById('activity-chart');
    if (!target || !window.uPlot || !shards.length) return;

    const MAX_CHART_SPAN_DAYS = 14;
    const points = shards.map(s => {
      const x = s.tmax_eff || s.tmax || s.tmin || 0;
      const tmin = s.tmin_eff || s.tmin || 0;
      const tmax = s.tmax_eff || s.tmax || 0;
      if (!x || !tmin || !tmax) return null;
      const spanDays = Math.max(1, Math.min(MAX_CHART_SPAN_DAYS, Math.round((tmax - tmin) / 86400)));
      const rate = (s.count || 0) / spanDays;
      if (!Number.isFinite(rate) || rate <= 0) return null;
      return { x, y: rate };
    }).filter(Boolean);
    const ys = points.map(p => p.y);
    if (!ys.length) return;

    const sortedRates = ys.slice().sort((a, b) => a - b);
    const medianRate = sortedRates[Math.floor(sortedRates.length / 2)] || 0;
    const filteredPoints = points.filter(p => {
      const year = new Date(p.x * 1000).getUTCFullYear();
      if (year >= 2012 && medianRate > 0 && p.y < medianRate * 0.02) return false;
      return true;
    });
    const xs = filteredPoints.map(p => p.x);
    const ysFiltered = filteredPoints.map(p => p.y);
    if (!xs.length) return;

    function wheelZoomPlugin({ factor = 0.75 } = {}) {
      return {
        hooks: {
          ready: u => {
            u.root.addEventListener('wheel', e => {
              e.preventDefault();
              const rect = u.root.getBoundingClientRect();
              const left = e.clientX - rect.left;
              const xVal = u.posToVal(left, 'x');
              const { min, max } = u.scales.x;
              const range = max - min;
              const zoom = e.deltaY < 0 ? factor : 1 / factor;
              const newRange = range * zoom;
              const pct = (xVal - min) / range;
              const newMin = xVal - newRange * pct;
              const newMax = xVal + newRange * (1 - pct);
              u.setScale('x', { min: newMin, max: newMax });
            }, { passive: false });
          }
        }
      };
    }

    function dragPanPlugin() {
      let dragging = false;
      let startX = 0;
      let startMin = 0;
      let startMax = 0;
      return {
        hooks: {
          ready: u => {
            u.root.addEventListener('mousedown', e => {
              dragging = true;
              startX = e.clientX;
              startMin = u.scales.x.min;
              startMax = u.scales.x.max;
            });
            window.addEventListener('mousemove', e => {
              if (!dragging) return;
              const dx = e.clientX - startX;
              const range = startMax - startMin;
              const px = u.bbox.width;
              const shift = range * (dx / px);
              u.setScale('x', { min: startMin - shift, max: startMax - shift });
            });
            window.addEventListener('mouseup', () => { dragging = false; });
          }
        }
      };
    }

    const data = [xs, ysFiltered];
    const opts = {
      width: target.clientWidth || 640,
      height: 220,
      padding: [8, 16, 28, 54],
      scales: { x: { time: true } },
      series: [
        {},
        { label: 'Items', stroke: '#0000cc', width: 1 }
      ],
      axes: [
        { stroke: '#828282', grid: { stroke: '#e0e0d6' }, size: 28 },
        { stroke: '#828282', grid: { stroke: '#e0e0d6' }, size: 54, label: 'Items/day' }
      ],
      plugins: [wheelZoomPlugin(), dragPanPlugin()]
    };

    new uPlot(opts, data, target);
  }

  function setupUserGrowthChart(growth) {
    const target = document.getElementById('user-growth-chart');
    if (!target || !window.uPlot || !growth || !growth.length) return;

    const xs = growth.map(g => {
      const [y, m] = String(g.month).split('-').map(Number);
      return Date.UTC(y, (m || 1) - 1, 1) / 1000;
    });
    const ys = growth.map(g => g.total_users || 0);
    if (!xs.length) return;

    const data = [xs, ys];
    const opts = {
      width: target.clientWidth || 640,
      height: 210,
      padding: [8, 16, 28, 54],
      scales: { x: { time: true } },
      series: [
        {},
        { label: 'Users (posted)', stroke: '#0000cc', width: 1 }
      ],
      axes: [
        { stroke: '#828282', grid: { stroke: '#e0e0d6' }, size: 28 },
        { stroke: '#828282', grid: { stroke: '#e0e0d6' }, size: 54 }
      ]
    };

    new uPlot(opts, data, target);
  }

  function setupUserActiveChart(active) {
    const target = document.getElementById('user-active-chart');
    if (!target || !window.uPlot || !active || !active.length) return;

    const xs = active.map(g => {
      const [y, m] = String(g.month).split('-').map(Number);
      return Date.UTC(y, (m || 1) - 1, 1) / 1000;
    });
    const ys = active.map(g => g.active_users || 0);
    if (!xs.length) return;

    const data = [xs, ys];
    const opts = {
      width: target.clientWidth || 640,
      height: 210,
      padding: [8, 16, 28, 54],
      scales: { x: { time: true } },
      series: [
        {},
        { label: 'Active users (posted)', stroke: '#0000cc', width: 1 }
      ],
      axes: [
        { stroke: '#828282', grid: { stroke: '#e0e0d6' }, size: 28 },
        { stroke: '#828282', grid: { stroke: '#e0e0d6' }, size: 54 }
      ]
    };

    new uPlot(opts, data, target);
  }

  async function renderArchiveView(token = 0) {
    setStatus('Loading archive…');
    const data = await loadArchiveIndex();
    if (token && token !== routeToken) return;

    const shards = (data.shards || []).slice().sort((a,b) => a.sid - b.sid);
    let userGrowth = [];
    let userActive = [];
    try {
      const um = await loadUserStatsManifest();
      userGrowth = um?.user_growth || [];
      userActive = um?.user_active || [];
    } catch {}
    const manifestRows = (data.manifests || []).map(m => `
      <tr>
        <td><span class="doc-icon"></span><a href="${m.file}">${m.file}</a></td>
        <td>${formatBytes(m.bytes)}</td>
        <td>${m.note || ''}</td>
      </tr>
    `).join('');

    tableEl.innerHTML = `
      <tr><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">Archive snapshot & totals</div>
        <table class="record-table">
          <tr><td class="record-label">Snapshot</td><td>${formatAbsoluteTime(data.snapshot_time)}</td></tr>
          <tr><td class="record-label">Shards</td><td>${(data.totals?.shards || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Items</td><td>${(data.totals?.items || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Posts</td><td>${(data.totals?.posts || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Comments</td><td>${(data.totals?.comments || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Size</td><td>${formatBytes(data.totals?.bytes || 0)}</td></tr>
        </table>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">HN activity over time (items/day)</div>
        <div id="activity-chart" class="archive-chart"></div>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">HN user growth (users with posts/comments)</div>
        <div id="user-growth-chart" class="archive-chart pad-bottom"></div>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">HN monthly active users (posting/commenting)</div>
        <div id="user-active-chart" class="archive-chart pad-bottom"></div>
      </td></tr>
      <tr><td style="padding:0 10px 8px 10px">
        <div class="subtext" style="margin-top:4px">
          <a href="https://dosaygo-studio.github.io/HackerBook/" target="_blank" rel="noopener">[GET THIS]</a> — download the static archive and run it locally.
        </div>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">Manifest files</div>
        <table class="archive-table">
          <tr><th>File</th><th>Size</th><th>Notes</th></tr>
          ${manifestRows || ''}
        </table>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">Shard index</div>
        <table class="archive-table">
          <tr><th>Shard</th><th>Start</th><th>End</th><th>Days</th><th>Posts</th><th>Comments</th><th>Items</th><th>Size</th></tr>
          <tbody id="archive-shard-body"></tbody>
        </table>
      </td></tr>
    `;

    const shardBody = document.getElementById('archive-shard-body');
    if (shardBody && shards.length) {
      const chunkSize = 200;
      let idx = 0;
      while (idx < shards.length) {
        const chunk = shards.slice(idx, idx + chunkSize);
        const html = chunk.map(s => {
          const tmin = s.tmin_eff || s.tmin;
          const tmax = s.tmax_eff || s.tmax;
          const start = formatDateShort(tmin);
          const end = formatDateShort(tmax);
          const spanDays = (tmin && tmax) ? Math.max(1, Math.round((tmax - tmin) / 86400)) : '';
          return `
            <tr>
              <td><span class="db-icon"></span><a href="static-shards/${s.file}">${s.file}</a></td>
              <td>${start}</td>
              <td>${end}</td>
              <td>${spanDays}</td>
              <td>${(s.posts || 0).toLocaleString('en-US')}</td>
              <td>${(s.comments || 0).toLocaleString('en-US')}</td>
              <td>${(s.count || 0).toLocaleString('en-US')}</td>
              <td>${formatBytes(s.bytes)}</td>
            </tr>
          `;
        }).join('');
        shardBody.insertAdjacentHTML('beforeend', html);
        idx += chunkSize;
        if (idx < shards.length) {
          await new Promise(r => requestAnimationFrame(() => r()));
          if (token && token !== routeToken) return;
        }
      }
    }

    requestAnimationFrame(() => {
      setupArchiveChart(shards);
      setupUserGrowthChart(userGrowth);
      setupUserActiveChart(userActive);
    });
    setStatus('');
  }

  async function renderQueryView(token = 0) {
    setStatus('');
    const schemaContent = `tables:\n  items(id INTEGER PRIMARY KEY, type TEXT, time INTEGER, by TEXT, title TEXT, text TEXT, url TEXT, score INTEGER, parent INTEGER)\n  edges(parent_id INTEGER, ord INTEGER, child_id INTEGER)\n\nexamples:\n  SELECT id, title, by, time, score FROM items WHERE type='story' ORDER BY score DESC LIMIT 30\n  SELECT by, COUNT(*) as items FROM items GROUP BY by ORDER BY items DESC LIMIT 20\n  SELECT * FROM items WHERE time BETWEEN 1700000000 AND 1700864000 LIMIT 100`;
    const schemaUsers = `tables:\n  users(username TEXT PRIMARY KEY, first_time INTEGER, last_time INTEGER, items INTEGER, comments INTEGER, stories INTEGER, ask INTEGER, show INTEGER, launch INTEGER, jobs INTEGER, polls INTEGER, avg_score REAL, sum_score INTEGER, max_score INTEGER, min_score INTEGER, max_score_id INTEGER, max_score_title TEXT)\n  user_domains(username TEXT, domain TEXT, count INTEGER)\n  user_months(username TEXT, month TEXT, count INTEGER)\n\nexamples:\n  SELECT username, items, comments, stories FROM users ORDER BY items DESC LIMIT 50\n  SELECT username, avg_score, max_score FROM users ORDER BY max_score DESC LIMIT 25\n  SELECT username, first_time, last_time FROM users ORDER BY last_time DESC LIMIT 25\n  SELECT domain, SUM(count) as posts FROM user_domains GROUP BY domain ORDER BY posts DESC LIMIT 50\n  SELECT month, SUM(count) as active FROM user_months GROUP BY month ORDER BY month DESC LIMIT 24`;
    const schemaAll = `${schemaContent}\n\n${schemaUsers}`;
    const allShards = (timeShards && timeShards.length)
      ? timeShards.map(s => s.sid)
      : (manifest?.shards || []).map(s => s.sid);
    let userShards = [];
    try {
      const um = await loadUserStatsManifest();
      userShards = (um?.shards || []).map(s => s.sid);
    } catch {}
    tableEl.innerHTML = `
      <tr><td style="padding:10px">
        <div class="subtext">Query the archive (SQL)</div>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">Schema</div>
        <div class="schema-block" id="query-schema"></div>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <textarea id="query-input" class="query-input" spellcheck="false">SELECT id, title, by, time, score FROM items WHERE type='story' ORDER BY time DESC LIMIT 30</textarea>
        <div class="subtext" style="margin:8px 0 4px 0">Template queries</div>
        <select id="query-template" class="warp-input top" title="Pick a prewritten query" style="margin-bottom:8px;">
          <option value="">Select a query…</option>
          <option value="stories-score">Top stories by score</option>
          <option value="stories-recent">Recent stories</option>
          <option value="comments-recent">Recent comments</option>
          <option value="ask-score">Ask HN leaderboard</option>
          <option value="show-score">Show HN leaderboard</option>
          <option value="polls-score">Top polls</option>
          <option value="stories-domain">Top story domains</option>
          <option value="users-items">Most prolific users</option>
          <option value="users-comments">Most active commenters</option>
          <option value="users-score">Highest max score users</option>
          <option value="users-fresh">Newest active users</option>
          <option value="users-gaps">Longest user spans</option>
          <option value="domains-users">Domains by unique users</option>
          <option value="domains-loyal">Domains by total user posts</option>
          <option value="users-months">Monthly active users</option>
        </select>
        <div class="subtext" style="margin:10px 0 4px 0">Shard filter (optional)</div>
        <select id="query-mode" class="warp-input top" title="Choose data source" style="margin-bottom:6px;">
          <option value="content">Content shards</option>
          <option value="users">User stats shards</option>
        </select>
        <div class="query-shards" id="query-shards"></div>
        <div class="query-shards-actions">
          <button class="time-step" id="query-shards-all" type="button">ALL / CLEAR</button>
          <span class="subtext" style="color:#666; font-style:italic;">Pick any shards to limit to just those.</span>
        </div>
        <div class="query-actions">
          <button class="time-step query-run" id="query-run" type="button">QUERY RUN</button>
          <span class="subtext" id="query-status"></span>
        </div>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">Results</div>
        <pre id="query-output" class="query-output">No query run.</pre>
      </td></tr>
    `;

    const input = document.getElementById('query-input');
    const status = document.getElementById('query-status');
    const output = document.getElementById('query-output');
    const runBtn = document.getElementById('query-run');
    const shardsWrap = document.getElementById('query-shards');
    const shardsAllBtn = document.getElementById('query-shards-all');
    const modeSelect = document.getElementById('query-mode');
    const schemaEl = document.getElementById('query-schema');
    const templateSelect = document.getElementById('query-template');
    let selectedTemplateKey = '';

    const templates = {
      'stories-score': {
        sql: "SELECT id, title, by, time, score FROM items WHERE type='story' ORDER BY score DESC LIMIT 30",
        mode: 'content'
      },
      'stories-recent': {
        sql: "SELECT id, title, by, time, score FROM items WHERE type='story' ORDER BY time DESC LIMIT 50",
        mode: 'content'
      },
      'comments-recent': {
        sql: "SELECT id, by, time, parent FROM items WHERE type='comment' ORDER BY time DESC LIMIT 50",
        mode: 'content'
      },
      'ask-score': {
        sql: "SELECT id, title, by, score FROM items WHERE type='story' AND title LIKE 'Ask HN:%' ORDER BY score DESC LIMIT 50",
        mode: 'content'
      },
      'show-score': {
        sql: "SELECT id, title, by, score FROM items WHERE type='story' AND title LIKE 'Show HN:%' ORDER BY score DESC LIMIT 50",
        mode: 'content'
      },
      'polls-score': {
        sql: "SELECT id, title, by, score FROM items WHERE type='poll' ORDER BY score DESC LIMIT 50",
        mode: 'content'
      },
      'stories-domain': {
        sql: "SELECT substr(url, instr(url, '//') + 2) as domain, COUNT(*) as posts FROM items WHERE type='story' AND url IS NOT NULL GROUP BY domain ORDER BY posts DESC LIMIT 50",
        mode: 'content'
      },
      'users-items': {
        sql: "SELECT username, items, comments, stories FROM users ORDER BY items DESC LIMIT 50",
        mode: 'users'
      },
      'users-comments': {
        sql: "SELECT username, comments FROM users ORDER BY comments DESC LIMIT 50",
        mode: 'users'
      },
      'users-score': {
        sql: "SELECT username, max_score, max_score_id, max_score_title FROM users ORDER BY max_score DESC LIMIT 30",
        mode: 'users'
      },
      'users-fresh': {
        sql: "SELECT username, first_time, last_time, items FROM users ORDER BY last_time DESC LIMIT 50",
        mode: 'users'
      },
      'users-gaps': {
        sql: "SELECT username, first_time, last_time FROM users ORDER BY (last_time - first_time) DESC LIMIT 50",
        mode: 'users'
      },
      'domains-users': {
        sql: "SELECT domain, COUNT(DISTINCT username) as users FROM user_domains GROUP BY domain ORDER BY users DESC LIMIT 50",
        mode: 'users'
      },
      'domains-loyal': {
        sql: "SELECT domain, SUM(count) as posts FROM user_domains GROUP BY domain ORDER BY posts DESC LIMIT 50",
        mode: 'users'
      },
      'users-months': {
        sql: "SELECT month, SUM(count) as active FROM user_months GROUP BY month ORDER BY month DESC LIMIT 36",
        mode: 'users'
      }
    };

    function renderSchema(mode) {
      if (!schemaEl) return;
      schemaEl.textContent = schemaAll;
    }

    function renderShardCheckboxes(mode) {
      if (!shardsWrap) return;
      const list = mode === 'users' ? userShards : allShards;
      shardsWrap.innerHTML = list.map(sid => (
        `<label><input type="checkbox" data-sid="${sid}"> shard ${sid}</label>`
      )).join(' ');
    }

    if (templateSelect && input) {
      templateSelect.addEventListener('change', () => {
        const key = templateSelect.value;
        selectedTemplateKey = key || '';
        if (!key || !templates[key]) return;
        input.value = templates[key].sql;
        if (modeSelect) {
          modeSelect.value = templates[key].mode;
          renderSchema(modeSelect.value);
          renderShardCheckboxes(modeSelect.value);
        }
      });
    }

    if (modeSelect) {
      modeSelect.addEventListener('change', () => {
        const mode = modeSelect.value || 'content';
        renderSchema(mode);
        renderShardCheckboxes(mode);
      });
    }

    renderSchema('content');
    renderShardCheckboxes('content');
    if (shardsAllBtn && shardsWrap) {
      shardsAllBtn.addEventListener('click', () => {
        shardsWrap.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; });
      });
    }
    if (shardsAllBtn && shardsWrap) {
      shardsAllBtn.addEventListener('click', () => {
        shardsWrap.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; });
      });
    }

    const MAX_ROWS = 500;

    function aggregateTemplateResults(rows, templateKey) {
      if (templateKey === 'users-months') {
        const byMonth = new Map();
        rows.forEach(r => {
          const m = r?.month;
          if (!m) return;
          const val = Number(r.active ?? r.count ?? 0) || 0;
          byMonth.set(m, (byMonth.get(m) || 0) + val);
        });
        return Array.from(byMonth.entries())
          .map(([month, active]) => ({ month, active }))
          .sort((a, b) => b.month.localeCompare(a.month));
      }
      return rows;
    }

    function addTimeDecorations(rows) {
      return rows.map(row => {
        if (!row || typeof row !== 'object') return row;
        const out = { ...row };
        Object.entries(row).forEach(([key, value]) => {
          if (value == null || typeof value !== 'number') return;
          if (!/time$/i.test(key) && !/first_time$/i.test(key) && !/last_time$/i.test(key)) return;
          if (value < 1000000000 || value > 9999999999) return;
          const iso = new Date(value * 1000).toISOString().slice(0, 10);
          out[`${key}_ymd`] = iso;
        });
        return out;
      });
    }

    async function runQuery() {
      if (!input || !output || !status) return;
      const raw = input.value || '';
      if (!isSafeQuery(raw)) {
        output.textContent = 'Only SELECT/CTE queries are allowed.';
        return;
      }
      const requestedLimit = getLimit(raw);
      const effectiveLimit = requestedLimit ? Math.min(requestedLimit, MAX_ROWS) : MAX_ROWS;
      const perShardLimit = Math.min(MAX_ROWS * 2, effectiveLimit * 2);
      const order = parseOrderBy(raw);
      const sql = addLimitIfMissing(raw, perShardLimit);
      const mode = modeSelect ? modeSelect.value : 'content';
      let shards = (mode === 'users' ? userShards : allShards).slice();
      if (shardsWrap) {
        const checked = Array.from(shardsWrap.querySelectorAll('input[type="checkbox"]:checked'))
          .map(cb => Number(cb.getAttribute('data-sid')))
          .filter(Number.isFinite);
        if (checked.length) shards = checked;
      }
      const results = [];
      let scanned = 0;
      let skipped = 0;
      status.textContent = requestedLimit && requestedLimit > MAX_ROWS
        ? `Running... (limit capped at ${MAX_ROWS})`
        : 'Running...';
      output.textContent = '';

      for (const sid of shards) {
        if (token && token !== routeToken) return;
        let db = null;
        try {
          db = mode === 'users'
            ? await loadUserStatsShardBySid(sid)
            : await loadShardBySid(sid);
        } catch (err) {
          skipped += 1;
          status.textContent = `Scanned ${scanned}/${shards.length} shard(s), skipped ${skipped}...`;
          continue;
        }
        scanned += 1;
        if (!db) {
          skipped += 1;
          status.textContent = `Scanned ${scanned}/${shards.length} shard(s), skipped ${skipped}...`;
          continue;
        }
        try {
          const rows = sqlAll(db, sql);
          results.push(...rows);
        } catch (err) {
          output.textContent = String(err && err.message ? err.message : err);
          status.textContent = '';
          return;
        }
        status.textContent = `Scanned ${scanned}/${shards.length} shard(s), skipped ${skipped}...`;
        await new Promise(r => requestAnimationFrame(() => r()));
      }

      const aggregated = aggregateTemplateResults(results, selectedTemplateKey);
      sortRows(aggregated, order);
      const trimmed = aggregated.slice(0, effectiveLimit);
      const decorated = addTimeDecorations(trimmed);
      output.textContent = JSON.stringify(decorated, null, 2) || 'No rows.';
      status.textContent = `Rows: ${trimmed.length} (skipped ${skipped})`;
    }

    if (runBtn) runBtn.addEventListener('click', runQuery);
    setStatus('');
  }

  async function renderUserView(username, token = 0) {
    setStatus('Loading user…');
    const uname = String(username || '').trim();
    const unameKey = normalizeUser(uname);
    if (!uname) {
      tableEl.innerHTML = `<tr><td style="padding:14px" class="loading">User not found.</td></tr>`;
      setStatus('');
      return;
    }

    const db = await loadUserStatsShard(unameKey);
    if (token && token !== routeToken) return;
    if (!db) {
      tableEl.innerHTML = `<tr><td style="padding:14px" class="loading">User stats not available.</td></tr>`;
      setStatus('');
      return;
    }

    const user = sqlOne(db, `SELECT * FROM users WHERE username=? COLLATE NOCASE LIMIT 1`, [unameKey]);
    if (!user) {
      tableEl.innerHTML = `<tr><td style="padding:14px" class="loading">User not found.</td></tr>`;
      setStatus('');
      return;
    }

    const first = formatAbsoluteTime(user.first_time);
    const last = formatAbsoluteTime(user.last_time);
    const spanDays = user.first_time && user.last_time ? Math.max(1, Math.round((user.last_time - user.first_time) / 86400)) : null;
    const avgPerDay = spanDays ? (user.items / spanDays).toFixed(2) : null;
    const bestTitle = user.max_score_title ? decodeEntities(user.max_score_title) : '[item]';

    tableEl.innerHTML = `
      <tr><td style="padding:10px">
        <div class="subtext">User archive record</div>
      </td></tr>
      <tr><td style="padding:0 10px 12px 10px">
        <table class="record-table">
          <tr><td class="record-label">User</td><td class="title">${uname}</td></tr>
          <tr><td class="record-label">First seen</td><td class="title">${first || 'n/a'}</td></tr>
          <tr><td class="record-label">Last seen</td><td class="title">${last || 'n/a'}</td></tr>
      ${spanDays ? `<tr><td class="record-label">Active span</td><td class="title">${spanDays.toLocaleString('en-US')} days</td></tr>` : ``}
      ${avgPerDay ? `<tr><td class="record-label">Avg items/day</td><td class="title">${avgPerDay}</td></tr>` : ``}
      <tr><td class="record-label">Items</td><td class="title">${(user.items || 0).toLocaleString('en-US')}</td></tr>
      <tr><td class="record-label">Comments</td><td class="title">${(user.comments || 0).toLocaleString('en-US')}</td></tr>
      <tr><td class="record-label">Stories</td><td class="title">${(user.stories || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Ask</td><td class="title">${(user.ask || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Show</td><td class="title">${(user.show || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Launch</td><td class="title">${(user.launch || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Jobs</td><td class="title">${(user.jobs || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Polls</td><td class="title">${(user.polls || 0).toLocaleString('en-US')}</td></tr>
          <tr><td class="record-label">Avg score</td><td class="title">${Number.isFinite(user.avg_score) ? user.avg_score.toFixed(2) : 'n/a'}</td></tr>
          <tr><td class="record-label">Best score</td><td class="title">${user.max_score != null ? user.max_score : 'n/a'}</td></tr>
          ${user.max_score_id ? `<tr><td class="record-label">Best item</td><td class="title"><a href="?view=item&id=${user.max_score_id}" data-spa>${bestTitle}</a></td></tr>` : ``}
        </table>
      </td></tr>
      <tr id="user-top-domains-row"><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">Top domains</div>
        <div class="loading">Loading…</div>
      </td></tr>
      <tr id="user-top-months-row"><td style="padding:0 10px 12px 10px">
        <div class="subtext" style="margin-bottom:6px">Top months</div>
        <div class="loading">Loading…</div>
      </td></tr>
    `;

    setStatus('Loading user stats…');

    (async () => {
      // Let the basic user table paint before running the heavier lookups.
      await new Promise(r => requestAnimationFrame(() => r()));

      const domRow = document.getElementById('user-top-domains-row');
      const monthRow = document.getElementById('user-top-months-row');

      const fetchDomains = (async () => {
        try {
          const topDomains = sqlAll(db, `
            SELECT domain, count FROM user_domains
            WHERE username=? COLLATE NOCASE ORDER BY count DESC, domain ASC LIMIT 8
          `, [unameKey]);
          if (token && token !== routeToken) return;
          if (topDomains.length && domRow) {
            domRow.innerHTML = `<td style="padding:0 10px 12px 10px">
              <div class="subtext" style="margin-bottom:6px">Top domains</div>
              <table class="archive-table">
                <tr><th>Domain</th><th>Count</th></tr>
                ${topDomains.map(d => `<tr><td>${d.domain}</td><td>${d.count}</td></tr>`).join('')}
              </table>
            </td>`;
          } else if (domRow) {
            domRow.remove();
          }
        } catch (err) {
          if (domRow) domRow.innerHTML = `<td style="padding:0 10px 12px 10px"><div class="loading">Top domains not available.</div></td>`;
        }
      })();

      const fetchMonths = (async () => {
        try {
          const topMonths = sqlAll(db, `
            SELECT month, count FROM user_months
            WHERE username=? COLLATE NOCASE ORDER BY count DESC, month DESC LIMIT 8
          `, [unameKey]);
          if (token && token !== routeToken) return;
          if (topMonths.length && monthRow) {
            monthRow.innerHTML = `<td style="padding:0 10px 12px 10px">
              <div class="subtext" style="margin-bottom:6px">Top months</div>
              <table class="archive-table">
                <tr><th>Month</th><th>Count</th></tr>
                ${topMonths.map(m => `<tr><td>${m.month}</td><td>${m.count}</td></tr>`).join('')}
              </table>
            </td>`;
          } else if (monthRow) {
            monthRow.remove();
          }
        } catch (err) {
          if (monthRow) monthRow.innerHTML = `<td style="padding:0 10px 12px 10px"><div class="loading">Top months not available.</div></td>`;
        }
      })();

      await Promise.allSettled([fetchDomains, fetchMonths]);

      if (!statusHoldUntil || Date.now() >= statusHoldUntil) setStatus('');
    })();
  }

  // -----------------------
  // Router
  // -----------------------
  async function route() {
    enableSPA();
    const token = ++routeToken;

    const p = qs();
    const view = p.get('view') || 'news';
    const page = Math.max(1, parseInt(p.get('p') || '1', 10));
    const id = p.get('id');
    const warp = p.get('warp') ? parseInt(p.get('warp'), 10) : null;
    const warpDate = p.get('warp_date');
    if (warpDate && timeRange.min && timeRange.max) {
      let ts = parseISODateUTC(warpDate, false);
      if (ts) {
        if (ts < timeRange.min) ts = timeRange.min;
        if (ts > timeRange.max) ts = timeRange.max;
        const iso = formatISODateUTC(ts);
        if (iso !== warpDate) {
          const targetShard = findShardForTs(ts);
          nav({ view, p: 1, warp: targetShard?.sid ?? null, warp_date: iso, id: null });
          return;
        }
      }
    }
    const targetReferenceTime = warpDate
      ? parseISODateUTC(warpDate, true)
      : (manifest?.snapshot_time || 0);

    const listViews = new Set(['news','newest','ask','show','jobs']);
    const deferReferenceTime = listViews.has(view);
    if (!deferReferenceTime) {
      setReferenceTime(targetReferenceTime, true);
    }
    if (warpDate) {
      setWarpInputs(warpDate);
    } else if (manifest?.snapshot_time) {
      setWarpInputs(formatISODateUTC(manifest.snapshot_time));
    }

    if (view === 'item' && id) {
      currentThreadId = Number(id);
      await renderThread(Number(id), token);
      initialRoute = false;
      return;
    }

    if (view === 'comment' && id) {
      currentThreadId = null;
      clearResumeStates();
      await renderCommentView(Number(id), token);
      initialRoute = false;
      return;
    }

    if (view === 'user' && id) {
      currentThreadId = null;
      clearResumeStates();
      await renderUserView(id, token);
      initialRoute = false;
      return;
    }

    if (view === 'archive') {
      currentThreadId = null;
      clearResumeStates();
      await renderArchiveView(token);
      if (token !== routeToken) return;
      history.replaceState({}, '', location.href);
      initialRoute = false;
      return;
    }

    if (view === 'query') {
      currentThreadId = null;
      clearResumeStates();
      await renderQueryView(token);
      initialRoute = false;
      return;
    }

    if (['news','newest','ask','show','jobs'].includes(view)) {
      currentThreadId = null;
      clearResumeStates();
      await listView(view, page, warp, warpDate, token);
      initialRoute = false;
      return;
    }

    nav({ view:'news', p:1 });
    initialRoute = false;
  }

  // -----------------------
  // Boot
  // -----------------------
  async function init() {
    try {
      setStatus('Loading manifest…');
      manifest = await fetchJsonMaybeGzip(PATHS.manifest);

      // Ensure shards sorted by id_lo for binary search correctness
      manifest.shards = (manifest.shards || []).slice().sort((a,b)=>a.id_lo-b.id_lo);
      try {
        archiveIndex = await fetchJsonMaybeGzip(PATHS.archiveIndex);
      } catch {}
      loadCrossIndex();
      rebuildTimeIndex();

      // Derive snapshot_time if not present (OG manifest has it; but be safe)
      if (!manifest.snapshot_time) {
        manifest.snapshot_time = (manifest.shards || []).reduce((m,s)=>Math.max(m, s.tmax||0), 0);
      }
      if (manifest.snapshot_time) {
        // Set warp input max to snapshot date
        const snapIso = formatISODateUTC(manifest.snapshot_time);
        getWarpInputs().forEach(input => {
          input.max = snapIso;
          input.value = snapIso;
        });

        const totalItems = (manifest.shards || []).reduce((m, s) => m + (s.count || 0), 0);
        const totalBytes = (manifest.shards || []).reduce((m, s) => m + (s.bytes || 0), 0);
        const totals = (manifest.shards || []).reduce((acc, s) => {
          const file = String(s.file || '');
          const isGz = file.endsWith('.gz');
          const bytes = Number(s.bytes) || 0;
          const rawEst = Number(s.raw_bytes_est);
          if (isGz) acc.gz += bytes;
          else acc.raw += bytes;
          if (Number.isFinite(rawEst)) acc.rawEst += rawEst;
          return acc;
        }, { raw: 0, gz: 0, rawEst: 0 });
        const tmin = (manifest.shards || []).reduce((m, s) => Math.min(m, s.tmin || m), Number.POSITIVE_INFINITY);
        const tmax = (manifest.shards || []).reduce((m, s) => Math.max(m, s.tmax || 0), 0);
        if (Number.isFinite(tmin) && tmax) {
          const start = formatDateShort(tmin);
          const end = formatDateShort(tmax);
          const gb = (totalBytes / (1024 ** 3)).toFixed(1);
          const rawBytes = Math.max(totals.rawEst, totals.raw);
          const rawGb = rawBytes > 0 ? (rawBytes / (1024 ** 3)).toFixed(1) : null;
          const gzGb = totals.gz > 0 ? (totals.gz / (1024 ** 3)).toFixed(1) : null;
          const sizeLabel = rawGb && gzGb
            ? `${rawGb}GB raw (${gzGb}GB gz)`
            : `${gb}GB`;
          statsInfoEl.textContent = `${totalItems.toLocaleString('en-US')} items, ${manifest.shards.length.toLocaleString('en-US')} shards, ${sizeLabel}, spanning ${start} to ${end}`;
        }

      if (!timeControlsBound) {
        timeControlsBound = true;
        // Warp handler - find stories from that date
        getWarpInputs().forEach(input => {
          input.addEventListener('change', () => {
            if (warpDebounce) clearTimeout(warpDebounce);
            warpDebounce = setTimeout(() => {
              navigateToWarpDate(input.value);
            }, 350);
          });
        });
        document.querySelectorAll('.time-step').forEach(btn => {
          btn.addEventListener('click', () => {
            const delta = parseInt(btn.getAttribute('data-step') || '0', 10);
            if (delta) stepWarpDate(delta);
          });
        });
      }
    }

      sqlite3 = await window.sqlite3InitModule();
      loadCollapsedState();

      const logoLink = document.getElementById('logo-link');
      if (logoLink) {
        logoLink.addEventListener('click', () => {
          if (!timeRange.min || !timeRange.max) return;
          const span = timeRange.max - timeRange.min;
          if (span <= 0) return;
          const ts = timeRange.min + Math.floor(Math.random() * span);
          const iso = formatISODateUTC(ts);
          setWarpInputs(iso);
          navigateToWarpDate(iso);
        });
      }

      const homeLink = document.getElementById('home-link');
      if (homeLink) {
        homeLink.addEventListener('click', (e) => {
          e.preventDefault();
          if (manifest?.snapshot_time) {
            setWarpInputs(formatISODateUTC(manifest.snapshot_time));
          }
          nav({ view: 'news', p: 1, warp: null, warp_date: null, id: null });
        });
      }

      const startLink = document.getElementById('start-link');
      if (startLink) {
        startLink.addEventListener('click', (e) => {
          e.preventDefault();
          const targetShard = findFirstShardWithPosts();
          if (!targetShard) return;
          const iso = formatISODateUTC(targetShard.tmin || targetShard.tmax || timeRange.min);
          setWarpInputs(iso);
          nav({ view: 'news', p: 1, warp: targetShard.sid, warp_date: iso, id: null });
        });
      }

      if (headerDateEl) {
        headerDateEl.addEventListener('click', (e) => {
          e.preventDefault();
          if (manifest?.snapshot_time) setWarpInputs(formatISODateUTC(manifest.snapshot_time));
          nav({ view: 'news', p: 1, warp: null, warp_date: null, id: null });
        });
      }

      window.addEventListener('popstate', () => route());
      await route();
    } catch (e) {
      tableEl.innerHTML = `<tr><td style="padding:14px"><div class="error">${String(e && e.stack ? e.stack : e)}</div></td></tr>`;
      setStatus('');
    }
  }

  // expose nav for onclick handlers
  window.nav = nav;
  window.toggleThread = toggleThread;
  window.addEventListener('scroll', () => {
    if (!currentThreadId || !threadCache.has(currentThreadId)) return;
    const cached = threadCache.get(currentThreadId);
    cached.scrollY = window.scrollY || 0;
  });

  init();
})();
</script>
</body>
</html>
